// Code generated by protoc-gw-gen. DO NOT EDIT.

package svc

import (
	"bytes"
	"context"
	"fmt"
	"mime"
	"net/http"
	"net/url"

	"github.com/golang/protobuf/jsonpb"
	"github.com/gorilla/schema"
)

//JobsCaller makes it easy to request from a server that runs the http1.1 handler
type JobsCaller struct {
	client *http.Client
	m      *jsonpb.Marshaler
	ep     *url.URL
}

//NewJobsCaller sets up the requester
func NewJobsCaller(c *http.Client, ep string) (r *JobsCaller, err error) {
	r = &JobsCaller{client: c, m: &jsonpb.Marshaler{}}
	r.ep, err = url.Parse(ep)
	if err != nil {
		return nil, fmt.Errorf("failed to parse endpoint for client: %v", err)
	}

	return r, nil
}

//JobsHandler serves a gRPC interface on a http1.1 handler
type JobsHandler struct {
	svc         JobsServer
	m           *jsonpb.Marshaler
	FormDecoder *schema.Decoder
}

//NewJobsHandler can be used to serve gRPC over http1.1 servers
func NewJobsHandler(svc JobsServer) *JobsHandler {
	return &JobsHandler{
		svc:         svc,
		m:           &jsonpb.Marshaler{},
		FormDecoder: schema.NewDecoder(),
	}
}

//CallCreate will call the remote procedure
func (r *JobsCaller) CallCreate(ctx context.Context, m, p string, i *CreateJobInput) (o *CreateJobOutput, err error) {
	ref, err := url.Parse(p)
	if err != nil {
		return nil, fmt.Errorf("failed to parse call path '%s': %v", p, err)
	}

	var body *bytes.Buffer
	if i != nil {
		body = bytes.NewBuffer(nil)
		err = r.m.Marshal(body, i)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal input: %v", err)
		}
	}

	uri := r.ep.ResolveReference(ref)
	req, err := http.NewRequest(m, uri.String(), body)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %v", err)
	}

	req = req.WithContext(ctx)
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	resp, err := r.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to perform request: %v", err)
	}

	o = &CreateJobOutput{}
	defer resp.Body.Close()
	err = jsonpb.Unmarshal(resp.Body, o)
	if err != nil {
		return nil, fmt.Errorf("failed to decode JSON response body: %s", err)
	}

	return o, nil
}

//HandleCreate Is a generated handler that calls a gRPC service procedure
func (s *JobsHandler) HandleCreate(w http.ResponseWriter, r *http.Request) {
	in := &CreateJobInput{}

	err := r.ParseForm()
	if err != nil {
		http.Error(w, fmt.Sprintf("failed to parse URL query or form body: %s", err), http.StatusBadRequest)
		return
	}

	if len(r.Form) > 0 {
		err = s.FormDecoder.Decode(in, r.Form)
		if err != nil {
			http.Error(w, fmt.Sprintf("failed to parse form schema: %s", err), http.StatusBadRequest)
			return
		}
	}

	mt, _, _ := mime.ParseMediaType(r.Header.Get("content-type"))

	defer r.Body.Close()
	if r.Body != nil && r.ContentLength != 0 && mt == "application/json" {
		err = jsonpb.Unmarshal(r.Body, in)
		if err != nil {
			http.Error(w, fmt.Sprintf("invalid request body: %s", err), http.StatusBadRequest)
			return
		}
	}

	out, err := s.svc.Create(r.Context(), in)
	if err != nil {
		http.Error(w, fmt.Sprintf("request failed: %s", err), http.StatusInternalServerError)
		return
	}

	err = s.m.Marshal(w, out)
	if err != nil {
		http.Error(w, fmt.Sprintf("failed to create response: %s", err), http.StatusInternalServerError)
		return
	}
}

//CallDelete will call the remote procedure
func (r *JobsCaller) CallDelete(ctx context.Context, m, p string, i *DeleteJobInput) (o *DeleteJobOutput, err error) {
	ref, err := url.Parse(p)
	if err != nil {
		return nil, fmt.Errorf("failed to parse call path '%s': %v", p, err)
	}

	var body *bytes.Buffer
	if i != nil {
		body = bytes.NewBuffer(nil)
		err = r.m.Marshal(body, i)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal input: %v", err)
		}
	}

	uri := r.ep.ResolveReference(ref)
	req, err := http.NewRequest(m, uri.String(), body)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %v", err)
	}

	req = req.WithContext(ctx)
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	resp, err := r.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to perform request: %v", err)
	}

	o = &DeleteJobOutput{}
	defer resp.Body.Close()
	err = jsonpb.Unmarshal(resp.Body, o)
	if err != nil {
		return nil, fmt.Errorf("failed to decode JSON response body: %s", err)
	}

	return o, nil
}

//HandleDelete Is a generated handler that calls a gRPC service procedure
func (s *JobsHandler) HandleDelete(w http.ResponseWriter, r *http.Request) {
	in := &DeleteJobInput{}

	err := r.ParseForm()
	if err != nil {
		http.Error(w, fmt.Sprintf("failed to parse URL query or form body: %s", err), http.StatusBadRequest)
		return
	}

	if len(r.Form) > 0 {
		err = s.FormDecoder.Decode(in, r.Form)
		if err != nil {
			http.Error(w, fmt.Sprintf("failed to parse form schema: %s", err), http.StatusBadRequest)
			return
		}
	}

	mt, _, _ := mime.ParseMediaType(r.Header.Get("content-type"))

	defer r.Body.Close()
	if r.Body != nil && r.ContentLength != 0 && mt == "application/json" {
		err = jsonpb.Unmarshal(r.Body, in)
		if err != nil {
			http.Error(w, fmt.Sprintf("invalid request body: %s", err), http.StatusBadRequest)
			return
		}
	}

	out, err := s.svc.Delete(r.Context(), in)
	if err != nil {
		http.Error(w, fmt.Sprintf("request failed: %s", err), http.StatusInternalServerError)
		return
	}

	err = s.m.Marshal(w, out)
	if err != nil {
		http.Error(w, fmt.Sprintf("failed to create response: %s", err), http.StatusInternalServerError)
		return
	}
}

//CallInspect will call the remote procedure
func (r *JobsCaller) CallInspect(ctx context.Context, m, p string, i *InspectJobInput) (o *InspectJobOutput, err error) {
	ref, err := url.Parse(p)
	if err != nil {
		return nil, fmt.Errorf("failed to parse call path '%s': %v", p, err)
	}

	var body *bytes.Buffer
	if i != nil {
		body = bytes.NewBuffer(nil)
		err = r.m.Marshal(body, i)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal input: %v", err)
		}
	}

	uri := r.ep.ResolveReference(ref)
	req, err := http.NewRequest(m, uri.String(), body)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %v", err)
	}

	req = req.WithContext(ctx)
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	resp, err := r.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to perform request: %v", err)
	}

	o = &InspectJobOutput{}
	defer resp.Body.Close()
	err = jsonpb.Unmarshal(resp.Body, o)
	if err != nil {
		return nil, fmt.Errorf("failed to decode JSON response body: %s", err)
	}

	return o, nil
}

//HandleInspect Is a generated handler that calls a gRPC service procedure
func (s *JobsHandler) HandleInspect(w http.ResponseWriter, r *http.Request) {
	in := &InspectJobInput{}

	err := r.ParseForm()
	if err != nil {
		http.Error(w, fmt.Sprintf("failed to parse URL query or form body: %s", err), http.StatusBadRequest)
		return
	}

	if len(r.Form) > 0 {
		err = s.FormDecoder.Decode(in, r.Form)
		if err != nil {
			http.Error(w, fmt.Sprintf("failed to parse form schema: %s", err), http.StatusBadRequest)
			return
		}
	}

	mt, _, _ := mime.ParseMediaType(r.Header.Get("content-type"))

	defer r.Body.Close()
	if r.Body != nil && r.ContentLength != 0 && mt == "application/json" {
		err = jsonpb.Unmarshal(r.Body, in)
		if err != nil {
			http.Error(w, fmt.Sprintf("invalid request body: %s", err), http.StatusBadRequest)
			return
		}
	}

	out, err := s.svc.Inspect(r.Context(), in)
	if err != nil {
		http.Error(w, fmt.Sprintf("request failed: %s", err), http.StatusInternalServerError)
		return
	}

	err = s.m.Marshal(w, out)
	if err != nil {
		http.Error(w, fmt.Sprintf("failed to create response: %s", err), http.StatusInternalServerError)
		return
	}
}

//CallList will call the remote procedure
func (r *JobsCaller) CallList(ctx context.Context, m, p string, i *ListJobsInput) (o *ListJobsOutput, err error) {
	ref, err := url.Parse(p)
	if err != nil {
		return nil, fmt.Errorf("failed to parse call path '%s': %v", p, err)
	}

	var body *bytes.Buffer
	if i != nil {
		body = bytes.NewBuffer(nil)
		err = r.m.Marshal(body, i)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal input: %v", err)
		}
	}

	uri := r.ep.ResolveReference(ref)
	req, err := http.NewRequest(m, uri.String(), body)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %v", err)
	}

	req = req.WithContext(ctx)
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	resp, err := r.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to perform request: %v", err)
	}

	o = &ListJobsOutput{}
	defer resp.Body.Close()
	err = jsonpb.Unmarshal(resp.Body, o)
	if err != nil {
		return nil, fmt.Errorf("failed to decode JSON response body: %s", err)
	}

	return o, nil
}

//HandleList Is a generated handler that calls a gRPC service procedure
func (s *JobsHandler) HandleList(w http.ResponseWriter, r *http.Request) {
	in := &ListJobsInput{}

	err := r.ParseForm()
	if err != nil {
		http.Error(w, fmt.Sprintf("failed to parse URL query or form body: %s", err), http.StatusBadRequest)
		return
	}

	if len(r.Form) > 0 {
		err = s.FormDecoder.Decode(in, r.Form)
		if err != nil {
			http.Error(w, fmt.Sprintf("failed to parse form schema: %s", err), http.StatusBadRequest)
			return
		}
	}

	mt, _, _ := mime.ParseMediaType(r.Header.Get("content-type"))

	defer r.Body.Close()
	if r.Body != nil && r.ContentLength != 0 && mt == "application/json" {
		err = jsonpb.Unmarshal(r.Body, in)
		if err != nil {
			http.Error(w, fmt.Sprintf("invalid request body: %s", err), http.StatusBadRequest)
			return
		}
	}

	out, err := s.svc.List(r.Context(), in)
	if err != nil {
		http.Error(w, fmt.Sprintf("request failed: %s", err), http.StatusInternalServerError)
		return
	}

	err = s.m.Marshal(w, out)
	if err != nil {
		http.Error(w, fmt.Sprintf("failed to create response: %s", err), http.StatusInternalServerError)
		return
	}
}

//CallLogs will call the remote procedure
func (r *JobsCaller) CallLogs(ctx context.Context, m, p string, i *JobLogsInput) (o *JobLogsOutput, err error) {
	ref, err := url.Parse(p)
	if err != nil {
		return nil, fmt.Errorf("failed to parse call path '%s': %v", p, err)
	}

	var body *bytes.Buffer
	if i != nil {
		body = bytes.NewBuffer(nil)
		err = r.m.Marshal(body, i)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal input: %v", err)
		}
	}

	uri := r.ep.ResolveReference(ref)
	req, err := http.NewRequest(m, uri.String(), body)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %v", err)
	}

	req = req.WithContext(ctx)
	req.Header.Set("Content-Type", "application/json; charset=utf-8")
	resp, err := r.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to perform request: %v", err)
	}

	o = &JobLogsOutput{}
	defer resp.Body.Close()
	err = jsonpb.Unmarshal(resp.Body, o)
	if err != nil {
		return nil, fmt.Errorf("failed to decode JSON response body: %s", err)
	}

	return o, nil
}

//HandleLogs Is a generated handler that calls a gRPC service procedure
func (s *JobsHandler) HandleLogs(w http.ResponseWriter, r *http.Request) {
	in := &JobLogsInput{}

	err := r.ParseForm()
	if err != nil {
		http.Error(w, fmt.Sprintf("failed to parse URL query or form body: %s", err), http.StatusBadRequest)
		return
	}

	if len(r.Form) > 0 {
		err = s.FormDecoder.Decode(in, r.Form)
		if err != nil {
			http.Error(w, fmt.Sprintf("failed to parse form schema: %s", err), http.StatusBadRequest)
			return
		}
	}

	mt, _, _ := mime.ParseMediaType(r.Header.Get("content-type"))

	defer r.Body.Close()
	if r.Body != nil && r.ContentLength != 0 && mt == "application/json" {
		err = jsonpb.Unmarshal(r.Body, in)
		if err != nil {
			http.Error(w, fmt.Sprintf("invalid request body: %s", err), http.StatusBadRequest)
			return
		}
	}

	out, err := s.svc.Logs(r.Context(), in)
	if err != nil {
		http.Error(w, fmt.Sprintf("request failed: %s", err), http.StatusInternalServerError)
		return
	}

	err = s.m.Marshal(w, out)
	if err != nil {
		http.Error(w, fmt.Sprintf("failed to create response: %s", err), http.StatusInternalServerError)
		return
	}
}
